#!/usr/bin/env bash


#main() {
#	render_usage_docs
#}
#
#render_usage_docs() {
#	local git_root="$(git rev-parse --show-toplevel)"
#	
#	# todo - stash ?
#	
#	# todo - get candidate changes
#
#	# install git-flux from source to get the local changes
#	${git_root}/bin/setup-dev.sh update || { exit 1; }
#
#	# render usage docs
#	${git_root}/bin/usage.sh || { exit 2; }
#
#	# todo - unstash ?
#
#	exit 0
#}
#
#
#main
#






#create_temp_file() {
#	mktemp 2>/dev/null || mktemp -t 'pre-commit-hook-changes'
#}

#cleanup() {
#	echo "deleting [$1]"
#	rm -f "$1"
#}

#create_patch() {
#	git diff --exit-code --binary --ignore-submodules --no-color > $1
#}

#patch_filename="$(create_temp_file)"
#echo "patch_filename: $patch_filename"
#trap 'cleanup '"$patch_filename" EXIT






#git_root="$(git rev-parse --show-toplevel)"
#cd ${git_root}
#echo "$(pwd)"


#if git rev-parse --verify HEAD >/dev/null 2>&1
#then
#    against=HEAD
#else
#    # Initial commit: diff against an empty tree object
#    against=$(git hash-object -t tree /dev/null)
#fi
#
#patch_filename=$(mktemp -t commit_hook_changes.XXXXXX)
#git diff --exit-code --binary --ignore-submodules --no-color > $patch_filename
#has_unstaged_changes=$?
#
#echo "has_unstaged_changes: $has_unstaged_changes"
#
#if [ $has_unstaged_changes -ne 0 ]; then
#    echo "Stashing unstaged changes in $patch_filename."
#    git checkout -- .
#fi
#
#quit() {
#    if [ $has_unstaged_changes -ne 0 ]; then
#        git apply $patch_filename
#        if [ $? -ne 0 ]; then
#            git checkout -- .
#            git apply $patch_filename
#        fi
#    fi
#
#    exit $1
#}
#
#
## Redirect output to stderr.
#exec 1>&2
#
#files_with_nocommit=$(git diff --cached --name-only --diff-filter=ACM $against | xargs grep -i "nocommit" -l | tr '\n' ' ')
#
#if [ "x${files_with_nocommit}x" != "xx" ]; then
#    tput setaf 1
#    echo "File being committed with 'nocommit' in it:"
#    echo $files_with_nocommit | tr ' ' '\n'
#    tput sgr0
#    quit 1
#fi
#
#quit 0








# First, stash index and work dir, keeping only the
# to-be-committed changes in the working directory.
old_stash=$(git rev-parse -q --verify refs/stash)
git stash save -q --keep-index
new_stash=$(git rev-parse -q --verify refs/stash)

echo "old_stash: $old_stash, new_stash: $new_stash"


# If there were no changes (e.g., `--amend` or `--allow-empty`)
# then nothing was stashed, and we should skip everything,
# including the tests themselves.  (Presumably the tests passed
# on the previous commit, so there is no need to re-run them.)
if [ "$old_stash" = "$new_stash" ]; then
    echo "pre-commit script: no changes to test"
    sleep 1 # XXX hack, editor may erase message
    exit 0
fi


# Run tests
status=0

# Restore changes
git reset --hard -q && git stash apply --index -q && git stash drop -q

# Exit with status from test-run: nonzero prevents commit
exit $status

