#!/usr/bin/env sh


# 
# little text formatters for terminal or markdown.
# 
# 
# environment:
#   [FORMAT=terminal|markdown]
# 
# 
# usage:
# 
# two possible ways:
# 
# - include the available _t_* tags within strings to wrap terms.
#   tags must be closed with the appropriate _t_*_off tag.
# 
# - use the formatter functions, they can be piped, or accept arguments.
# 
# 
# examples:
# 
# - wrapping with tags:
#   echo "this text will be ${_t_bold}bold${_t_bold_off}"
#   echo "text can be ${_t_under}underlined${_t_under_off} as well"
#   echo "color text in ${_t_fg_yellow}yellow${_t_fg_off} or ${_t_fg_blue}blue${_t_fg_off}"
# 
# - using functions:
# 
#       echo "$(t_heading "foo")"
#       echo "$(echo "foo" | t_heading)"
#       echo "$(echo "foo" | t_heading | t_fg_yellow)"
# 
#   you can also skip the echo, and combine the functions in any which way:
# 
#       echo "$(t_heading "foo" | t_fg_yellow)"
# 
# 
# caveats:
# 
# - _t_bold cannot be nested and must be the outermost tag, as _t_bold_off will 
#   reset any other style.
# 



# todo - how to describe lists? (in terminal) probably just pad lines with leading space
# todo - fill in the gaps between the terminal and the markdown (e.g. markdown 
# todo -    has `code`, terminal will return the bold style when using ${t_code}.
# todo - also, describe headers (that has ------- underline in terminal text), 
# todo -    (github) markdown already has this supported for H1/H2 (===/---), use it.


t_util_wrap() {
	local tag="$1"; shift; local tagoff="$1"; shift
	local input=$(get_input "$@")
	printf "${tag}%s${tagoff}" "$input"
}

t_util_prefix() {
	local prefix="$1"; shift
	local input=$(get_input "$@")
	printf "${prefix}%s" "$input"
}

t_util_underline() {
	local char="$1"; shift
	local suffix="$1"; shift
	local input=$(get_input "$@")
	printf "%s\n$(repeat ${char} ${#input})" "$input$suffix"
}


t_init_terminal() {

	# todo - headings, lists etc.

	[[ -t 2 ]] && { # in a terminal session
	
		_t_bold=$(       tput bold   || tput md      )
		_t_bold_off=$(   tput sgr0                   )
		_t_italic=$(     tput sitm   || tput ZH      )
		_t_italic_off=$( tput ritm   || tput ZR      )
		_t_under=$(      tput smul   || tput us      )
		_t_under_off=$(  tput rmul   || tput ue      )
		_t_strike=$'\033[9m'
		_t_strike_off=$'\033[29m'
		_t_code=$_t_bold
		_t_code_off=$_t_bold_off
		
		_t_fg_off=$(                 tput setaf 0    || tput AF 0    )
		if (( $(tput colors) >= 256 )); then
			_t_fg_red=$(             tput setaf 167  || tput AF 167  )
			_t_fg_green=$(           tput setaf 107  || tput AF 107  )
			_t_fg_yellow=$(          tput setaf 179  || tput AF 179  )
			_t_fg_blue=$(            tput setaf 74   || tput AF 74   )
			_t_fg_magenta=$(         tput setaf 182  || tput AF 182  )
			_t_fg_cyan=$(            tput setaf 30   || tput AF 30   )
			_t_fg_lightred=$(        tput setaf 174  || tput AF 174  )
			_t_fg_lightgreen=$(      tput setaf 191  || tput AF 191  )
			_t_fg_lightyellow=$(     tput setaf 222  || tput AF 222  )
			_t_fg_lightblue=$(       tput setaf 153  || tput AF 153  )
			_t_fg_lightmagenta=$(    tput setaf 219  || tput AF 219  )
			_t_fg_lightcyan=$(       tput setaf 116  || tput AF 116  )
		elif (( $(tput colors) >= 8 )); then
			_t_fg_red=$(             tput setaf 1    || tput AF 1    )
			_t_fg_green=$(           tput setaf 2    || tput AF 2    )
			_t_fg_yellow=$(          tput setaf 3    || tput AF 3    )
			_t_fg_blue=$(            tput setaf 4    || tput AF 4    )
			_t_fg_magenta=$(         tput setaf 5    || tput AF 5    )
			_t_fg_cyan=$(            tput setaf 6    || tput AF 6    )
			_t_fg_lightred=$_t_fg_red
			_t_fg_lightgreen=$_t_fg_green
			_t_fg_lightyellow=$_t_fg_yellow
			_t_fg_lightblue=$_t_fg_blue
			_t_fg_lightmagenta=$_t_fg_magenta
			_t_fg_lightcyan=$_t_fg_cyan
		fi

		t_heading() {
			t_util_underline '-' "$_t_fg_off" "$@" | t_util_wrap "$_t_bold" "$_t_bold_off"
		}
		t_subheading() {
			t_util_wrap "$_t_under" "$_t_under_off" "$@"
		}
		t_list_item() {
			echo "$@"
		}

	} 2>/dev/null ||: # protect from "unknown terminfo capability" errors 

}

t_init_markdown() {
	
	_t_bold='**'
	_t_bold_off=$_t_bold
	_t_italic='_'
	_t_italic_off=$_t_italic
	_t_strike='~~'
	_t_strike_off=$_t_strike

	_t_code='`'
	_t_code_off=$_t_code

	t_heading() {       t_util_prefix   '### '      "$1"; }
	t_subheading() {    t_util_prefix   '##### '    "$1"; }
	t_list_item() {     t_util_prefix   ' - '       "$1"; }

	# colors could be possible with html, if they're not stripped down by the markdown parser. haven't tested it
#	_t_fg_off=$'</span>'
#	_t_fg_red=$'<span style="color: #c75646">'
#	_t_fg_green=$'<span style="color: #8eb33b">'
#	_t_fg_yellow=$'<span style="color: #d0b03c">'
#	_t_fg_blue=$'<span style="color: #72b3cc">'
#	_t_fg_magenta=$'<span style="color: #c8a0d1">'
#	_t_fg_cyan=$'<span style="color: #218693">'
#	_t_fg_lightred=$'<span style="color: #e09690">'
#	_t_fg_lightgreen=$'<span style="color: #cdee69">'
#	_t_fg_lightyellow=$'<span style="color: #ffe377">'
#	_t_fg_lightblue=$'<span style="color: #9cd9f0">'
#	_t_fg_lightmagenta=$'<span style="color: #fbb1f9">'
#	_t_fg_lightcyan=$'<span style="color: #77dfd8">'
}

t_init_api() {

	# todo - do we need these "$@"? these functions are piped, so why explicitly pass in the arguments?
	t_bold() {              t_util_wrap     "$_t_bold"          "$_t_bold_off"      "$@"; }
	t_italic() {            t_util_wrap     "$_t_italic"        "$_t_italic_off"    "$@"; }
	t_strike() {            t_util_wrap     "$_t_strike"        "$_t_strike_off"    "$@"; }
	t_code() {              t_util_wrap     "$_t_code"          "$_t_code_off"      "$@"; }
	t_under() {             t_util_wrap     "$_t_under"         "$_t_under_off"     "$@"; }

	t_fg_red() {            t_util_wrap     "$_t_fg_red"            "$_t_fg_off"    "$@"; }
	t_fg_green() {          t_util_wrap     "$_t_fg_green"          "$_t_fg_off"    "$@"; }
	t_fg_yellow() {         t_util_wrap     "$_t_fg_yellow"         "$_t_fg_off"    "$@"; }
	t_fg_blue() {           t_util_wrap     "$_t_fg_blue"           "$_t_fg_off"    "$@"; }
	t_fg_magenta() {        t_util_wrap     "$_t_fg_magenta"        "$_t_fg_off"    "$@"; }
	t_fg_cyan() {           t_util_wrap     "$_t_fg_cyan"           "$_t_fg_off"    "$@"; }
	t_fg_lightred() {       t_util_wrap     "$_t_fg_lightred"       "$_t_fg_off"    "$@"; }
	t_fg_lightgreen() {     t_util_wrap     "$_t_fg_lightgreen"     "$_t_fg_off"    "$@"; }
	t_fg_lightyellow() {    t_util_wrap     "$_t_fg_lightyellow"    "$_t_fg_off"    "$@"; }
	t_fg_lightblue() {      t_util_wrap     "$_t_fg_lightblue"      "$_t_fg_off"    "$@"; }
	t_fg_lightmagenta() {   t_util_wrap     "$_t_fg_lightmagenta"   "$_t_fg_off"    "$@"; }
	t_fg_lightcyan() {      t_util_wrap     "$_t_fg_lightcyan"      "$_t_fg_off"    "$@"; }

}

t_init_main() {
	case "$FORMAT" in
		terminal)
			t_init_terminal
			;;
		markdown)
			t_init_markdown
			;;
		*)
			t_init_terminal
			;;
			
		# todo - support formats: text/ansi/markdown to differentiate simple text from ansi-styled text
		# todo - headings can be reused to text mode
	esac
	t_init_api
}


t_init_main
