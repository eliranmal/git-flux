#!/usr/bin/env sh


cmd_usage_default() {
	printf "team <create|destroy|sync|join> <name> [-h]"
}

cmd_usage_create() {
	printf "team create <name> [-h]"
}

cmd_usage_destroy() {
	printf "team destroy <name> [-h]"
}

cmd_usage_join() {
	printf "team join <name> [-h]"
}

cmd_usage_sync() {
	printf "team sync <name> [-h]"
}

cmd_long_usage_default() {
	printf "\
${t_bold}${t_fg_yellow}team${t_fg_off}${t_bold_off}
----

handle integration across team members and their features.


${t_under}available actions${t_under_off}

$(cmd_long_usage_create)
$(cmd_long_usage_destroy)
$(cmd_long_usage_join)
$(cmd_long_usage_sync)
"
}

cmd_long_usage_create() {
	printf "\
   ${t_bold}$(cmd_usage_create)${t_bold_off}
      start a new team; create a local branch and push it to the remote.
      the branch name will be composed of the pre-configured team prefix and the passed ${t_bold}name${t_bold_off}.
      aliases: ${t_bold}assemble${t_bold_off}, ${t_bold}gather${t_bold_off}, ${t_bold}huddle${t_bold_off}.
 "
}

cmd_long_usage_destroy() {
	printf "\
   ${t_bold}$(cmd_usage_destroy)${t_bold_off}
      destroy an existing team; delete its local and remote branches, for good.
      aliases: ${t_bold}disassemble${t_bold_off}, ${t_bold}scatter${t_bold_off}, ${t_bold}break${t_bold_off}.
 "
}

cmd_long_usage_join() {
	printf "\
   ${t_bold}$(cmd_usage_join)${t_bold_off}
      join a team for the first time, or switch teams to another team.
      after this, all new features will be based on the new team.
      aliases: ${t_bold}switch${t_bold_off}.
 "
}

cmd_long_usage_sync() {
	printf "\
   ${t_bold}$(cmd_usage_sync)${t_bold_off}
      sync an existing team with its base branch (the integration branch).
 "
}


# aliases 

cmd_assemble() { cmd_create "$@"; }
cmd_gather() { cmd_create "$@"; }
cmd_huddle() { cmd_create "$@"; }
cmd_disassemble() { cmd_destroy "$@"; }
cmd_scatter() { cmd_destroy "$@"; }
cmd_break() { cmd_destroy "$@"; }
cmd_switch() { cmd_join "$@"; }


cmd_create() {
	require_args "$1"
	local branch="$(git_config_get "prefix.team")$1"
	io_log; create_branch_from_base "$branch" "$(git_config_get "branch.integration")"
	git_config_set "branch.team" "$branch"
	io_log; io_log_ok "team '$1' is created. congrats!"; io_log
}

cmd_destroy() {
	require_args "$1"
	io_log; destroy_branch_from_base "$(git_config_get "prefix.team")$1"
	git_config_unset "branch.team" "$branch"
	io_log; io_log_ok "team '$1' is gone. so long!"; io_log
}

cmd_sync() {
	require_args "$1"
	io_log; sync_branch_with_base "$(git_config_get "prefix.team")$1"
	io_log; io_log_ok "team '$1' is in sync with the base."; io_log
}

cmd_join() {
	require_args "$1"

	local prefix="$(git_config_get "prefix.team")"
	local new_team_branch="$prefix$1"
	local old_team_branch="$(git_config_get "branch.team")"
	local new_team="$1"
	local old_team="$(strip_prefix "$old_team_branch" "$prefix")"

	validate_git_local_and_remote_branches_exist "$new_team_branch"
	
	if [[ $new_team_branch = $old_team_branch ]]; then
		io_log; io_status_fatal "'$new_team' is the current team, nothing to do."
	fi

	# todo - should this block be used in 'finish' as well?
	# relevant when switching teams, not when joining a team for the first time
	if [[ -n $old_team_branch ]]; then
		validate_git_local_and_remote_branches_exist "$old_team_branch"
		
		local old_team_feature_branches="$(git_config_get_subsections_by_value "base" "$old_team_branch" "branch:")"
		if [[ -n $old_team_feature_branches ]]; then
			# strip prefix to get the team name
			io_log; io_log_info "feature branches of the '$old_team' team were found:"
			io_log "$old_team_feature_branches" 1
			io_confirm "ignore them and continue?" "aborting, see ya later."
		fi
	fi

	io_log
	git_checkout "$new_team_branch"
	git_config_set "branch.team" "$new_team_branch"

	io_log; io_log_ok "team switched. welcome aboard!"; io_log
}
