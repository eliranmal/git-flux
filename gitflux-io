#!/usr/bin/env sh


main() {
	# initialize text styling
	t_bold=$(tput bold)
	t_reset=$(tput sgr0)
	if (( $(tput colors) >= 8 )); then
		t_fg_red=$(tput setaf 1)
		t_fg_green=$(tput setaf 2)
		t_fg_yellow=$(tput setaf 3)
		t_fg_blue=$(tput setaf 4)
		t_fg_magenta=$(tput setaf 5)
		t_fg_cyan=$(tput setaf 6)
		t_fg_white=$(tput setaf 7)
    fi
}


# all those unicode characters (✔, ✘ etc.) may not show in git-bash, f*** that.

io_log() {
	io_print "   " "$@"
}

io_log_ok() {
	io_print " ✔ " "$@"
}

io_log_info() {
	io_print " ℹ " "$@"
}

io_log_star() {
	io_print " ★ " "$@"
}

io_log_warn() {
	io_print " ✘ " "$@" >&2
}

io_status_fatal() {
	die "$(io_print " ✘ " "$@")" >&2
}

io_prompt() {
	local question="$1"; default_suggestion="$2"
	if [[ -n $default_suggestion ]]; then
		question="${question} [$default_suggestion]"
	fi
	# use -p instead of sending the question to stdout, as this function will probably be 
	# called in a $(subshell), so printing to stdout won't work as expected
	read -r -p "$(printf " ？%s " "$question")" answer
	echo "${answer:-$default_suggestion}"
}

io_confirm() {
	local question="$1"; local exit_message="$2";
	local answer=$(io_prompt "$question (y/n)")
	if [[ $answer != "y" ]]; then
		io_status_fatal "$exit_message"
	fi
}

io_print() {
	local margin="$1"; local body="$2"; local indent_level=$3 # intentionally don't quote indent_level
	local message="$margin$body"
	if [[ $indent_level =~ [123] ]]; then
		local indent=""
		until (( $indent_level == 0 )); do
			indent="   $indent"
			let indent_level-=1
		done
		echo "$indent$message"
	else
		echo "$message"
	fi
}


main "$@"
