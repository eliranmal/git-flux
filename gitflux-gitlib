#!/usr/bin/env sh


git_local_branches() {
	git branch --no-color | sed 's/^[* ] //'
}

git_remote_branches() {
	git branch -r --no-color | sed 's/^[* ] //'
}

git_all_branches() {
	( git branch --no-color; git branch -r --no-color) | sed 's/^[* ] //'
}

git_all_tags() {
	git tag
}

git_current_branch() {
	git branch --no-color | grep '^\* ' | grep -v 'no branch' | sed 's/^* //g'
}

git_is_clean_working_tree() {
	if ! git diff --no-ext-diff --ignore-submodules --quiet --exit-code; then
		return 1
	elif ! git diff-index --cached --quiet --ignore-submodules HEAD --; then
		return 2
	else
		return 0
	fi
}

git_repo_is_headless() {
	! git rev-parse --quiet --verify HEAD >/dev/null 2>&1
}

git_local_branch_exists() {
	has $1 $(git_local_branches)
}

git_remote_branch_exists() {
	has $1 $(git_remote_branches)
}

git_branch_exists() {
	has $1 $(git_all_branches)
}

git_tag_exists() {
	has $1 $(git_all_tags)
}




# - - - - -  actions (safe) - - - - - #


git_checkout() {
	local branch="$1"
	io_log "switching to '$branch'..."
	git checkout "$branch" >/dev/null 2>&1 && {
		io_log_ok "switched to '$branch'" 1
	} || {
		io_status_fatal "switching to '$branch' failed" 1
	}
}

git_delete_local_branch() {
	local branch="$1"
	io_log "deleting the '$branch' local branch..."
	git branch -D "$branch" >/dev/null 2>&1 && {
		io_log_ok "'$branch' deleted locally" 1
	} || {
		io_status_fatal "delete of local '$branch' failed" 1
	}
}

git_delete_remote_branch() {
	local branch="$1"
	io_log "deleting the '$branch' remote branch..."
	git push origin :"$branch" >/dev/null 2>&1 && {
		io_log_ok "'$branch' deleted remotely" 1
	} || {
		io_status_fatal "delete of remote '$branch' failed" 1
	}
}

git_pull() {
	io_log "updating from the remote..."
	git pull >/dev/null 2>&1 && {
		io_log_ok "updated from the remote" 1
	} || {
		io_status_fatal "updating from the remote failed" 1
	}
}

git_create_branch() {
	local branch="$1"
	io_log "creating the '$branch' local branch and switching to it..."
	git checkout -b "$branch" >/dev/null 2>&1 && {
		io_log_ok "'$branch' was created and is now the current branch" 1
	} || {
		io_status_fatal "creating '$branch' failed" 1
	}
}

git_push() {
	local ref="$1"
	io_log "pushing '$ref' to the remote..."
	git push origin "$ref" >/dev/null 2>&1 && {
		io_log_ok "'$ref' pushed to the remote" 1
	} || {
		io_status_fatal "pushing '$ref' to the remote failed" 1
	}
}

git_push_new_branch() {
	local branch="$1"
	io_log "pushing new branch '$branch' to the remote..."
	git push --set-upstream origin "$branch" >/dev/null 2>&1 && {
		io_log_ok "'$branch' pushed to the remote" 1
	} || {
		io_status_fatal "pushing '$branch' to the remote failed" 1
	}
}

git_merge() {
	local branch="$1"
	io_log "merging changes from '$branch'..."
	git merge --no-edit "$branch" >/dev/null 2>&1 && {
		io_log_ok "merged from '$branch'" 1
	} || {
		io_status_fatal "conflicts were found during the merge from '$branch', resolve them in your favorite merge tool" 1
	}
}

git_tag() {
	local tag="$1"
	local message="$2"
	io_log "creating tag '$tag'..."
	git tag -a "$tag" -m "$message" >/dev/null 2>&1 && {
		io_log_ok "tag '$tag' created" 1
	} || {
		io_status_fatal "creating tag '$tag' failed" 1
	}
}




# - - - - -  git config - - - - - #


git_config_get() {
	local namespace="$1"
	echo "$(git config --global --get "$namespace")"
}

git_config_set() {
	local namespace="$1"
	local value="$2"
	git config --global "$namespace" "$value"
}

git_config_get_subsections_by_value() {
	local section="$1"
	local key="$2"
	local filter_value="$3"	
	local subsection_list
	
	local matching_lines="$(git config --global --get-regexp "$section"'\..*\.'"$key")"
	while read -r line
	do
		# example lines:
		# gitflux-branch-base.team/superstars.ref integration
		# gitflux-branch-base.rc/0.0.201.ref integration

		# take the value as base branch
		local value="$(echo "$line" | cut -d ' ' -f 2)"
		# if any of the bases is the current base, collect its branch into a list used to prompt the user later
		if [[ $value = $filter_value ]]; then
			# strip down key prefix "gitflux-branch-base." and suffix ".ref" to get the branch name
			local subsection="$(echo "$line" | cut -d ' ' -f 1 | sed -e 's,'"$section"'\.\(.*\)\.'"$key"',\1,')"
			if [[ -n $subsection ]]; then
				subsection_list="$subsection_list $subsection"
			fi
		fi
	done <<< "$matching_lines"

	echo "$subsection_list"
}

git_config_escape_subsection() {
	printf "%s" "$1" | sed 's,\([\\\"]\),\\\1,g' # '\' and '"' must be escaped in git config subsection names
}
