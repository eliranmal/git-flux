#!/usr/bin/env sh


git_local_branches() {
	git branch --no-color | sed 's/^[* ] //'
}

git_remote_branches() {
	git branch -r --no-color | sed 's/^[* ] //'
}

git_all_branches() {
	( git branch --no-color; git branch -r --no-color) | sed 's/^[* ] //'
}

git_all_tags() {
	git tag
}

git_current_branch() {
	git branch --no-color | grep '^\* ' | grep -v 'no branch' | sed 's/^* //g'
}

git_is_clean_working_tree() {
	if ! git diff --no-ext-diff --ignore-submodules --quiet --exit-code; then
		return 1
	elif ! git diff-index --cached --quiet --ignore-submodules HEAD --; then
		return 2
	else
		return 0
	fi
}

git_repo_is_headless() {
	! git rev-parse --quiet --verify HEAD >/dev/null 2>&1
}

git_local_branch_exists() {
	has $1 $(git_local_branches)
}

git_remote_branch_exists() {
	has $1 $(git_remote_branches)
}

git_branch_exists() {
	has $1 $(git_all_branches)
}

git_tag_exists() {
	has $1 $(git_all_tags)
}

git_tag_template() {
	local version="$1"; local suffix="$2"
	# todo - decide what the template will be
	printf "v%s%s" "$version" "$suffix"
}



# - - - - -  actions (safe) - - - - - #


git_checkout() {
	local branch="$1"
	io_log "checking out '$branch'..."
	git checkout "$branch" >/dev/null 2>&1 && {
		io_log_ok "'$branch' checked out" 1
	} || {
		io_status_fatal "checkout of '$branch' failed" 1
	}
}

git_delete_local_branch() {
	local branch="$1"
	io_log "deleting the '$branch' local branch..."
	git branch -D "$branch" >/dev/null 2>&1 && {
		io_log_ok "'$branch' deleted" 1
	} || {
		io_status_fatal "delete of '$branch' failed" 1
	}
}

git_delete_remote_branch() {
	local branch="$1"
	io_log "deleting the '$branch' remote branch..."
	git push origin :"$branch" >/dev/null 2>&1 && {
		io_log_ok "'$branch' deleted" 1
	} || {
		io_status_fatal "deletion of '$branch' failed" 1
	}
}

git_pull() {
	io_log "pulling from the remote..."
	git pull >/dev/null 2>&1 && {
		io_log_ok "pulled ok" 1
	} || {
		io_status_fatal "pull failed" 1
	}
}

git_push() {
	local ref="$1"
	io_log "pushing '$ref' to the remote..."
	git push origin "$ref" >/dev/null 2>&1 && {
		io_log_ok "'$ref' pushed" 1
	} || {
		io_status_fatal "push of '$ref' failed" 1
	}
}

git_create_branch() {
	local branch="$1"
	io_log "creating the '$branch' local branch..."
	git checkout -b "$branch" >/dev/null 2>&1 && {
		io_log_ok "'$branch' created and checked out" 1
	} || {
		io_status_fatal "creation of '$branch' failed" 1
	}
}

git_push_new_branch() {
	local branch="$1"
	io_log "pushing new branch '$branch' to the remote..."
	git push --set-upstream origin "$branch" >/dev/null 2>&1 && {
		io_log_ok "'$branch' pushed" 1
	} || {
		io_status_fatal "push of '$branch' failed" 1
	}
}

git_merge() {
	local branch="$1"
	io_log "merging changes from '$branch'..."
	git merge --no-edit "$branch" >/dev/null 2>&1 && {
		io_log_ok "merged from '$branch'" 1
	} || {
		io_status_fatal "conflicts were found during the merge from '$branch', resolve them in your favorite merge tool" 1
	}
}

git_create_tag() {
	local tag="$1"; local message="$2"
	io_log "creating tag '$tag'..."
	git tag -a "$tag" -m "$message" >/dev/null 2>&1 && {
		io_log_ok "'$tag' created" 1
	} || {
		io_status_fatal "creation of '$tag' failed" 1
	}
}




# - - - - -  git config - - - - - #


git_config_section="gitflux"

git_config_get() {
	local namespace="$1"
	echo "$(git config --global --get "$git_config_section.$namespace")"
}

git_config_set() {
	local namespace="$1"; local value="$2"
	git config --global "$git_config_section.$namespace" "$value"
}

git_config_remove_section() {
	local namespace="$1"
	git config --global --remove-section "$git_config_section.$namespace"	
}

git_config_get_subsections_by_value() {
	local key="$1"; local value="$2"; local prefix="$3"
	local subsection_list; local config_value; local config_subsection
	local config_lines="$(git config --global --get-regexp "$git_config_section"'\..*\.'"$key")"
	while read -r line; do
		# extract the config value
		config_value="$(echo "$line" | cut -d ' ' -f 2)"
		# if it does not match the passed value filter, abort this line
		[[ -n $value && $config_value != $value ]] && continue
		# strip down the section and key name to get the subsection
		config_subsection="$(echo "$line" | cut -d ' ' -f 1 | sed -e 's,'"$git_config_section"'\.\(.*\)\.'"$key"',\1,')"
		# strip down the prefix, if passed
		if [[ -n $prefix ]]; then
			config_subsection="$(echo "$config_subsection" | sed -e 's,'"$prefix"'\(.*\),\1,')"
		fi
		# add subsection to the result list
		subsection_list="$subsection_list $config_subsection"
	done <<< "$config_lines"
	# remove leading spaces and send to stdout
	echo "$subsection_list" | sed -e 's,^ *,,'
}

git_config_escape_subsection() {
	printf "%s" "$1" | sed 's,\([\\\"]\),\\\1,g' # '\' and '"' must be escaped in git config subsection names
}
