#!/usr/bin/env sh


git_local_branches() {
	git branch --no-color | sed 's/^[* ] //'
}

git_remote_branches() {
	git branch -r --no-color | sed 's/^[* ] //'
}

git_all_branches() {
	( git branch --no-color; git branch -r --no-color) | sed 's/^[* ] //'
}

git_all_tags() {
	git tag
}

git_current_branch() {
	git branch --no-color | grep '^\* ' | grep -v 'no branch' | sed 's/^* //g'
}

git_is_clean_working_tree() {
	if ! git diff --no-ext-diff --ignore-submodules --quiet --exit-code; then
		return 1
	elif ! git diff-index --cached --quiet --ignore-submodules HEAD --; then
		return 2
	else
		return 0
	fi
}

git_repo_is_headless() {
	! git rev-parse --quiet --verify HEAD >/dev/null 2>&1
}

git_can_prune() {
	( git remote prune origin --dry-run)
}

git_prune() {
	git remote prune origin >/dev/null 2>&1
}

git_local_branch_exists() {
	has $1 $(git_local_branches)
}

git_remote_branch_exists() {
	if [[ -n $(git_can_prune) ]]; then
		git_prune
	fi
	has "origin/$1" $(git_remote_branches)
}

git_branch_exists() {
	has $1 $(git_all_branches)
}

git_tag_exists() {
	has $1 $(git_all_tags)
}

git_is_different() {
	( git diff "$1" "$2" --no-color)
}



# - - - - -  actions (verbose) - - - - - #


git_checkout() {
	local branch="$1"
	io_log "checking out '$branch'..."
	git checkout "$branch" >/dev/null 2>&1
	io_status_logger $? "checked out" "checkout failed"
}

git_delete_local_branch() {
	local branch="$1"
	io_log "deleting the '$branch' local branch..."
	git branch -D "$branch" >/dev/null 2>&1
	io_status_logger $? "deleted ok" "delete failed"
}

git_delete_remote_branch() {
	local branch="$1"
	io_log "deleting the '$branch' remote branch..."
	git push origin :"$branch" >/dev/null 2>&1
	io_status_logger $? "deleted ok" "delete failed"
}

git_pull() {
	io_log "pulling from the remote..."
	git pull >/dev/null 2>&1
	io_status_logger $? "pulled ok" "pull failed"
}

git_push() {
	local ref="$1" # ref can be 'branch' or 'tag'
	io_log "pushing '$ref' to the remote..."
	git push origin "$ref" >/dev/null 2>&1
	io_status_logger $? "pushed ok" "push failed"
}

git_create_branch() {
	local branch="$1"
	local remote="${2:+origin/$2}" # remote name is optional
	io_log "creating the '$branch' local branch..."
	git checkout -b "$branch" ${remote} >/dev/null 2>&1
	io_status_logger $? "created and checked out" "create failed"
}

git_push_set_upstream() {
	local branch="$1"
	io_log "pushing '$branch' to the remote and setting upstream..."
	git push --set-upstream origin "$branch" >/dev/null 2>&1
	io_status_logger $? "pushed ok, upstream set" "push upstream failed"
}

git_ensure_branch() {
	local branch="$1"
	if git_local_branch_exists "$branch" && git_remote_branch_exists "$branch"; then
		return 0
	fi
	if git_remote_branch_exists "$branch"; then
		git_create_branch "$branch" "$branch"
	else
		if ! git_local_branch_exists "$branch"; then
			git_create_branch "$branch"
		fi
		git_push_set_upstream "$branch"
	fi
}

git_ensure_no_branch() {
	local branch="$1"
	if ! git_local_branch_exists "$branch" && ! git_remote_branch_exists "$branch"; then
		return 0
	fi
	if git_local_branch_exists "$branch"; then
		git_delete_local_branch "$branch"
	fi
	if git_remote_branch_exists "$branch"; then
		git_delete_remote_branch "$branch"
	fi
}

git_ensure_merged() {
	local branch="$1"; local base_branch="$2"
	git_checkout "$base_branch"
	git_pull
	git_checkout "$branch"
	git_pull
	if [[ -n $(git_is_different "$branch" "$base_branch") ]]; then
		git_merge "$base_branch"
	fi
}

git_merge() {
	local branch="$1"
	io_log "merging changes from '$branch'..."
	git merge --no-edit "$branch" >/dev/null 2>&1
	io_status_logger $? "merged ok" "conflicts were found during the merge, resolve them in your favorite merge tool"
}

git_create_tag() {
	local tag="$1"; local message="$2"
	io_log "creating tag '$tag'..."
	git tag -a "$tag" -m "$message" >/dev/null 2>&1
	io_status_logger $? "created ok" "create failed"
}




# - - - - -  git config - - - - - #


git_config_section="gitflux"

git_config_get() {
	local namespace="$1"
	echo "$(git config --global --get "$git_config_section.$namespace")"
}

git_config_set() {
	local namespace="$1"; local value="$2"
	git config --global "$git_config_section.$namespace" "$value"
}

git_config_unset() {
	local namespace="$1"
	git config --global --unset "$git_config_section.$namespace"
}

git_config_remove_section() {
	local namespace="$1"
	git config --global --remove-section "$git_config_section.$namespace"	
}

git_config_get_subsections_by_value() {
	local key="$1"; local value="$2"; local prefix="$3"
	local subsection_list; local config_value; local config_subsection
	local config_lines="$(git config --global --get-regexp "$git_config_section"'\..*\.'"$key")"
	while read -r line; do
		# extract the config value
		config_value="$(echo "$line" | cut -d ' ' -f 2)"
		# if it does not match the passed value filter, abort this line
		[[ -n $value && $config_value != $value ]] && continue
		# strip down the section and key name to get the subsection
		config_subsection="$(echo "$line" | cut -d ' ' -f 1 | sed -e 's,'"$git_config_section"'\.\(.*\)\.'"$key"',\1,')"
		# strip down the prefix, if passed
		if [[ -n $prefix ]]; then
			config_subsection="$(echo "$config_subsection" | sed -e 's,'"$prefix"'\(.*\),\1,')"
		fi
		# add subsection to the result list
		subsection_list="$subsection_list $config_subsection"
	done <<< "$config_lines"
	# remove leading spaces and send to stdout
	echo "$subsection_list" | sed -e 's,^ *,,'
}

git_config_escape_subsection() {
	printf "%s" "$1" | sed 's,\([\\\"]\),\\\1,g' # '\' and '"' must be escaped in git config subsection names
}
