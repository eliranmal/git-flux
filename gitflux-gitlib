#!/usr/bin/env sh


git_local_branches() {
	git branch --no-color | sed 's/^[* ] //'
}

git_remote_branches() {
	git branch -r --no-color | sed 's/^[* ] //'
}

git_all_branches() {
	( git branch --no-color; git branch -r --no-color) | sed 's/^[* ] //'
}

git_all_tags() {
	git tag
}

git_current_branch() {
	git branch --no-color | grep '^\* ' | grep -v 'no branch' | sed 's/^* //g'
}

git_is_clean_working_tree() {
	if ! git diff --no-ext-diff --ignore-submodules --quiet --exit-code; then
		return 1
	elif ! git diff-index --cached --quiet --ignore-submodules HEAD --; then
		return 2
	else
		return 0
	fi
}

git_repo_is_headless() {
	! git rev-parse --quiet --verify HEAD >/dev/null 2>&1
}

git_local_branch_exists() {
	has $1 $(git_local_branches)
}

git_remote_branch_exists() {
	has $1 $(git_remote_branches)
}

git_branch_exists() {
	has $1 $(git_all_branches)
}

git_tag_exists() {
	has $1 $(git_all_tags)
}



# - - - - -  actions (safe) - - - - - #


# todo - try to DRY up the && {} || {} stuff with command piping: (command) | func

git_checkout() {
	local branch="$1"
	io_log "checking out '$branch'..."
	git checkout "$branch" >/dev/null 2>&1 && {
		io_log_ok "checked out" 1
	} || {
		io_status_fatal "checkout failed" 1
	}
}

git_delete_local_branch() {
	local branch="$1"
	io_log "deleting the '$branch' local branch..."
	git branch -D "$branch" >/dev/null 2>&1 && {
		io_log_ok "deleted ok" 1
	} || {
		io_status_fatal "delete failed" 1
	}
}

git_delete_remote_branch() {
	local branch="$1"
	io_log "deleting the '$branch' remote branch..."
	git push origin :"$branch" >/dev/null 2>&1 && {
		io_log_ok "deleted ok" 1
	} || {
		io_status_fatal "delete failed" 1
	}
}

git_delete_local_and_remote_branches() {
	local branch="$1"
	git_delete_local_branch "$branch"
	git_delete_remote_branch "$branch"
}

git_pull() {
	io_log "pulling from the remote..."
	git pull >/dev/null 2>&1 && {
		io_log_ok "pulled ok" 1
	} || {
		io_status_fatal "pull failed" 1
	}
}

git_push() {
	local ref="$1" # ref can be 'branch' or 'tag'
	io_log "pushing '$ref' to the remote..."
	git push origin "$ref" >/dev/null 2>&1 && {
		io_log_ok "pushed ok" 1
	} || {
		io_status_fatal "push failed" 1
	}
}

git_create_branch() {
	local branch="$1"
	io_log "creating the '$branch' local branch..."
	git checkout -b "$branch" >/dev/null 2>&1 && {
		io_log_ok "created and checked out" 1
	} || {
		io_status_fatal "create failed" 1
	}
}

git_push_set_upstream() {
	local branch="$1"
	io_log "pushing '$branch' to the remote and setting upstream..."
	git push --set-upstream origin "$branch" >/dev/null 2>&1 && {
		io_log_ok "pushed ok, upstream set" 1
	} || {
		io_status_fatal "push upstream failed" 1
	}
}

git_create_and_push_branch() {
	local branch="$1"
	git_create_branch "$branch"
	git_push_set_upstream "$branch"
}

git_ensure_branch() {
	local branch="$1"
	io_log "looking for '$branch' locally..."
	# no need to check the remote branch exists, we'd wanna set it as the upstream anyways
	if git_local_branch_exists "$branch"; then
		io_log_ok "found" 1
		git_checkout "$branch"
	else
		io_log_warn "not found" 1
		git_create_branch "$branch"
	fi
	git_push_set_upstream "$branch"
}

git_merge() {
	local branch="$1"
	io_log "merging changes from '$branch'..."
	git merge --no-edit "$branch" >/dev/null 2>&1 && {
		io_log_ok "merged ok" 1
	} || {
		io_status_fatal "conflicts were found during the merge, resolve them in your favorite merge tool" 1
	}
}

git_create_tag() {
	local tag="$1"; local message="$2"
	io_log "creating tag '$tag'..."
	git tag -a "$tag" -m "$message" >/dev/null 2>&1 && {
		io_log_ok "created ok" 1
	} || {
		io_status_fatal "create failed" 1
	}
}




# - - - - -  git config - - - - - #


git_config_section="gitflux"

git_config_get() {
	local namespace="$1"
	echo "$(git config --global --get "$git_config_section.$namespace")"
}

git_config_set() {
	local namespace="$1"; local value="$2"
	git config --global "$git_config_section.$namespace" "$value"
}

git_config_unset() {
	local namespace="$1"
	git config --global --unset "$git_config_section.$namespace"
}

git_config_remove_section() {
	local namespace="$1"
	git config --global --remove-section "$git_config_section.$namespace"	
}

git_config_get_subsections_by_value() {
	local key="$1"; local value="$2"; local prefix="$3"
	local subsection_list; local config_value; local config_subsection
	local config_lines="$(git config --global --get-regexp "$git_config_section"'\..*\.'"$key")"
	while read -r line; do
		# extract the config value
		config_value="$(echo "$line" | cut -d ' ' -f 2)"
		# if it does not match the passed value filter, abort this line
		[[ -n $value && $config_value != $value ]] && continue
		# strip down the section and key name to get the subsection
		config_subsection="$(echo "$line" | cut -d ' ' -f 1 | sed -e 's,'"$git_config_section"'\.\(.*\)\.'"$key"',\1,')"
		# strip down the prefix, if passed
		if [[ -n $prefix ]]; then
			config_subsection="$(echo "$config_subsection" | sed -e 's,'"$prefix"'\(.*\),\1,')"
		fi
		# add subsection to the result list
		subsection_list="$subsection_list $config_subsection"
	done <<< "$config_lines"
	# remove leading spaces and send to stdout
	echo "$subsection_list" | sed -e 's,^ *,,'
}

git_config_escape_subsection() {
	printf "%s" "$1" | sed 's,\([\\\"]\),\\\1,g' # '\' and '"' must be escaped in git config subsection names
}
