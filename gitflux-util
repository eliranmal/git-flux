#!/usr/bin/env bash


has() {
	local item=$1; shift
	echo " $@ " | grep -q " $(escape $item) "
}

is() {
	[[ -n $1 ]]
}

escape() {
	echo "$1" | sed 's/\([\.\$\*]\)/\\\1/g'
}

is_available() {
	type $1 >/dev/null 2>&1
}

strip_prefix() {
	echo "$1" | sed -e 's,^'"$2"',,'
}

os_value() {
	local val
	if [[ $OSTYPE = "linux-gnu" || $OSTYPE = "darwin"* ]]; then # linux / mac osx
		val=$1
	elif [[ $OSTYPE = "msys" ]]; then # mingw
		val=$2
	fi
	printf "%s" "$val"
}

create_temp_dir() {
	mktemp -d 2>/dev/null || mktemp -d -t "$1"
}

url_last_path_seg() {
	sed -e 's,.*[/:]\([^/]*\)/[^/]*$,\1,'
}

url_domain() {
	sed -e 's,[^:/]*://\([^/]*\)/.*$,\1,'
}

json_get() {
	json_select '["'"$1"'"]'
}

json_select() {
	local selector="$1"	
	# check node is available
	if hash node 2>/dev/null; then
		local src='
			var data=JSON.parse(process.argv[1] || "{}");
			var val=data'"$selector"';
			console.log(typeof val === "undefined" ? "" : typeof val === "string" ? val : JSON.stringify(val));
		'
		node -e "$src" "$(cat -)" 2>/dev/null
	fi
}

# simple implementation: only escapes '\', '"' and new-lines
json_escape_string() {
	local str="$1"
	str="$(echo "$str" | sed -e '0N' -e 's,\(["\]\),\\\1,g')"
	printf "%s" "${str//$'\n'/\n}"
}
